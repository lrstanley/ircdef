// Copyright (c) Liam Stanley <me@liamstanley.io>. All rights reserved. Use
// of this source code is governed by the MIT license that can be found in
// the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"strings"

	"github.com/dave/jennifer/jen"
)

const license = `
// Copyright (c) Liam Stanley <me@liamstanley.io>. All rights reserved. Use
// of this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Authors of the dataset used to generate this file:
//   Copyright (c) 2015-2016 Daniel Oaks <daniel@danieloaks.net>
//   Copyright (c) 2001-2004 Simon Butcher <pickle@alien.net.au>
//   & %s/blob/%s/LICENSE
//
// DO NOT EDIT THIS FILE, IT HAS BEEN GENERATED AND WILL BE OVERWRITTEN.`

func writeFile(f *jen.File, path string) {
	buf := &bytes.Buffer{}

	if strings.HasSuffix(path, ".go") {
		_, err := buf.WriteString(strings.TrimLeft(fmt.Sprintf(license, strings.TrimSuffix(flags.Git.Repo, ".git"), flags.Git.Branch), "\n") + "\n\n")
		if err != nil {
			logger.Fatal(err)
		}
	}

	if err := f.Render(buf); err != nil {
		logger.Fatal(err)
	}

	logger.Printf("writing file %q", path)
	if err := ioutil.WriteFile(path, buf.Bytes(), 0644); err != nil {
		logger.Fatal(err)
	}
}

func multiPkgComment(f *jen.File, comment string) {
	for _, line := range strings.Split(strings.TrimLeft(comment, "\n"), "\n") {
		f.PackageComment(line)
	}
}

func multiPkgCommentf(f *jen.File, format string, a ...interface{}) {
	multiPkgComment(f, fmt.Sprintf(format, a...))
}

const maxLineSize = 70

// splitComment breaks up a (potentially multi-line) comment into multiple
// lines, with only so much length per line. Primarily useful for keeping
// generated code (that has documentation) clean.
func splitComment(maxSize int, comment string) (out string) {
	if maxSize <= 0 {
		maxSize = maxLineSize
	}

	count := 0
	for _, line := range strings.Split(comment, "\n") {
		if len(line) <= maxSize {
			out += line + "\n"
			continue
		}
		count = 0
		for _, word := range strings.Split(line, " ") {
			if len(word) >= maxSize || count+len(word)+1 >= maxSize {
				out += "\n" + word
				count = len(word)
				continue
			}

			if count == 0 {
				out += "\n" + word
				count += 1 + len(word)
			} else {
				out += " " + word
				count += 1 + len(word)
			}
		}
		out += "\n"
	}
	out = strings.Replace(out, "\n\n\n", "\n\n", -1)
	return strings.Trim(strings.TrimLeft(out, " "), "\n")
}

func splitCommentf(maxSize int, comment string, a ...interface{}) (out string) {
	return splitComment(maxSize, fmt.Sprintf(comment, a...))
}

// convertMultiComment converts Jennifers multiline (/* stuff */) that it
// uses when you use newlines, into multiple // based comments, as /* stuff */
// is really frowned upon.
func convertMultiComment(input string) *jen.Statement {
	var statement *jen.Statement
	for _, line := range strings.Split(input, "\n") {
		if statement == nil {
			statement = jen.Comment(line).Line()
			continue
		}
		statement.Comment(line).Line()
	}
	return statement
}

func convertMultiCommentf(input string, a ...interface{}) {
	convertMultiComment(fmt.Sprintf(input, a...))
}

// toSentences adds capitalization to the first word, and a period if there
// isn't one already.
func toSentence(comment string) string {
	if len(comment) < 2 {
		return comment
	}
	return strings.ToUpper(string(comment[0])) + strings.TrimSuffix(string(comment[1:]), ".") + "."
}
